[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "thalia"
version = "0.1.0"
description = "Thinking Architecture via Learning Integrated Attractors - A framework for genuinely thinking spiking neural networks"
readme = "README.md"
license = "MIT"
requires-python = ">=3.10"
authors = [
    { name = "THALIA Contributors" }
]
keywords = [
    "spiking-neural-networks",
    "SNN",
    "neuromorphic",
    "STDP",
    "attractor-networks",
    "cognitive-architecture",
    "artificial-intelligence"
]
classifiers = [
    "Development Status :: 2 - Pre-Alpha",
    "Intended Audience :: Science/Research",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Scientific/Engineering :: Artificial Intelligence",
]

dependencies = [
    "numpy>=1.20",
    "matplotlib>=3.4",
    "scipy>=1.7",
    "torch>=2.0",
    "tqdm",
    "psutil>=5.9",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-cov>=4.0",
    "pytest-timeout>=2.0",
    "pytest-benchmark>=4.0",
    "hypothesis>=6.0",
    "black",
    "isort",
    "mypy",
    "ruff",
]
experiments = [
    "jupyter",
    "ipywidgets",
    "seaborn",
    "pandas",
]
visualization = [
    "manim>=0.17.0",
]
all = [
    "thalia[dev,experiments,visualization]",
]

[project.urls]
Documentation = "https://github.com/kevin-heitfeld/thalia#readme"
Repository = "https://github.com/kevin-heitfeld/thalia"

[tool.hatch.build.targets.wheel]
packages = ["src/thalia"]

[tool.black]
line-length = 88
target-version = ["py310"]

[tool.isort]
profile = "black"
line_length = 88

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
addopts = "-v --tb=short"

[tool.coverage.run]
source = ["src/thalia"]
omit = [
    "*/tests/*",
    "*/temp/*",
    "*/experiments/*",
    "*/__pycache__/*",
]
branch = true

[tool.coverage.report]
# Fail CI if coverage drops below this threshold
fail_under = 80
precision = 2
show_missing = true
skip_covered = false
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
    "@abstractmethod",
    "@abc.abstractmethod",
]

[tool.coverage.html]
directory = "htmlcov"

# =============================================================================
# Pylint Configuration
# =============================================================================
# Suppress false positives and noise while keeping useful checks.
# These settings reflect the realities of our AI/ML codebase:
# - Type stubs incomplete for PyTorch/NumPy
# - Forward references needed for circular imports
# - Dynamic features (dataclasses, protocols, mixins)
# - Research code exploration patterns

[tool.pylint.main]
# Use multiple processes for faster linting
jobs = 0

# Pickle collected data for later comparisons
persistent = true

# Discover python modules and packages in the file system subtree
recursive = true

[tool.pylint.messages_control]
# Disable specific warnings that create noise without value
disable = [
    # === Type Checking Issues (handled by mypy) ===
    "no-member",                    # Often wrong for torch.Tensor, dynamic attrs
    "not-callable",                 # Wrong for __call__ methods, functorch
    "unsubscriptable-object",       # Wrong for generics, protocols
    "unsupported-membership-test",  # Wrong for __contains__ protocols
    "unsupported-assignment-operation",  # Wrong for __setitem__ protocols
    "unbalanced-tuple-unpacking",   # Often wrong for dataclass fields
    
    # === Import/Module Issues ===
    "import-error",                 # False positives with namespace packages
    "no-name-in-module",           # Wrong for torch, numpy submodules
    "cyclic-import",               # Acceptable with TYPE_CHECKING guards
    
    # === Code Style (handled by black/ruff) ===
    "line-too-long",               # Black handles this
    "missing-module-docstring",    # Not every file needs module docs
    "missing-class-docstring",     # Dataclasses often self-documenting
    "missing-function-docstring",  # Helper functions often self-documenting
    
    # === Design Decisions (intentional patterns) ===
    "too-many-arguments",          # Config classes need many params
    "too-many-instance-attributes",  # Brain regions are complex
    "too-many-locals",             # Forward passes have many intermediate values
    "too-many-branches",           # State machines need branches
    "too-many-statements",         # Complex initialization is fine
    "too-few-public-methods",      # Protocols, mixins, utilities
    "too-many-public-methods",     # Brain API is intentionally rich
    
    # === Protected Access (intentional for internal APIs) ===
    "protected-access",            # _impl access is part of our architecture
    
    # === Unused Variables (often wrong) ===
    "unused-argument",             # Protocol methods, hooks, callbacks
    "unused-variable",             # Intentional in comprehensions, unpacking
    
    # === Abstract Methods (handled by type checker) ===
    "abstract-method",             # Mypy catches this better
    
    # === Fixme Comments (we use TODO.md) ===
    "fixme",                       # We track TODOs separately
    
    # === Duplicate Code (acceptable in tests, configs) ===
    "duplicate-code",              # Test setup often similar
    
    # === Invalid Names (research code patterns) ===
    "invalid-name",                # x, y, z, W, b are standard in ML
    
    # === Broad Exception Catching (intentional for robustness) ===
    "broad-exception-caught",      # Catch-all needed in cleanup, __del__
    
    # === Redefined Outer Name (intentional shadowing) ===
    "redefined-outer-name",        # Pytest fixtures do this intentionally
]

[tool.pylint.format]
# Maximum number of characters on a single line
max-line-length = 100  # Slightly more lenient than black (88)

[tool.pylint.basic]
# Good variable names (ML conventions)
good-names = [
    "i", "j", "k",       # Loop indices
    "x", "y", "z",       # Coordinates, inputs
    "W", "b",            # Weights, biases
    "lr", "dt",          # Learning rate, timestep
    "CA1", "CA3", "DG",  # Hippocampus regions
    "L23", "L4", "L5",   # Cortical layers
    "fc", "bn",          # Fully connected, batch norm
    "fn",                # Function callback
    "f", "g", "h",       # Generic functions
    "pe",                # Prediction error
    "td",                # Temporal difference
    "rpe",               # Reward prediction error
]

[tool.pylint.design]
# Maximum number of arguments for function/method (we need this for configs)
max-args = 10

# Maximum number of attributes for a class (brain regions are complex)
max-attributes = 15

# Maximum number of boolean expressions in an if statement
max-bool-expr = 5

[tool.pylint.similarities]
# Minimum lines number of a similarity (to ignore small duplications)
min-similarity-lines = 10

# Comments are removed from the similarity computation
ignore-comments = true

# Docstrings are removed from the similarity computation  
ignore-docstrings = true

# Imports are removed from the similarity computation
ignore-imports = true
